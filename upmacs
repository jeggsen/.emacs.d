#!emacs --script

;;; Setup

;; make sure to print everything
(setq inhibit-message nil)

(defconst straight-build-dir (expand-file-name (locate-user-emacs-file "straight/build/")))
(defconst straight-repo-dir (expand-file-name (locate-user-emacs-file "straight/repos/")))

(defmacro req (feature)
  "Convenience macro for requiring packages."
  `(progn
     (add-to-list 'load-path (concat straight-build-dir (symbol-name ,feature)))
     (require ,feature)))

(req 'dash)
(req 's)
(req 'f)

(defun msg (txt &rest args)
  "Print the format-string TXT to stdout."
  (let ((output (apply #'format (cons txt args))))
    (princ output)
    (unless (s-ends-with-p "\n" output)
      (princ "\n"))))

;; load `straight'
(let ((bootstrap-file (concat straight-repo-dir "straight.el/bootstrap.el")))
  (if bootstrap-file
      (load bootstrap-file nil 'nomessage)
    (error "could not locate straight.el bootstrap file")))

;;; Core functionality

(defun upmacs-usage ()
  "Print script usage."
  (msg "help:             show usage")
  (msg "ls, list:         list all straight packages")
  (msg "update <pkg(s)>:  update specific package(s)")
  (msg "update-all:       update all packages"))

(defun upmacs-list ()
  "List all packages."
  (let* ((pkgs (f-directories straight-build-dir))
         (names (-map #'f-base pkgs)))
    (-map #'msg names)))

(defun upmacs-remove ()
  "Remove a package by name."
  (let ((pkg (pop argv)))
    (cond
     ((null pkg) (error "no package provided"))
     (t
      (ignore-errors
        (let* ((file (concat pkg ".el"))
               (build-dir (f-join straight-build-dir pkg))
               (build-src-file (f-join build-dir file))
               ;; the build-src-file is a symlink to the repo
               ;; directory, we use this to get the location of the
               ;; repository directory.
               (symlink (file-symlink-p build-src-file))
               (repo-dir (when symlink (f-dirname symlink))))
          (when (and build-dir (f-directory-p build-dir))
            (msg "removing %s" build-dir)
            (f-delete build-dir 'force))
          (when (and repo-dir (f-directory-p repo-dir))
            (msg "removing %s" repo-dir)
            (f-delete repo-dir 'force))))))))

(defun upmacs-update ()
  "Update one or more packages by name."
  (let* ((pkgs ()))
    (while argv
      (add-to-list 'pkgs (pop argv) 'append))
    (cond
     ((null pkgs) (error "no package(s) provided"))
     (t
      (dolist (pkg pkgs)
        (straight-pull-package pkg)
        (straight-rebuild-package pkg))))))

(defun upmacs-update-all ()
  "Update all packages."
  (let ((failed-packages (straight-pull-all)))
    (if failed-packages
        (msg "failed to update %s" failed-packages)
      (msg "updated all packages."))))

(defun _get-commit (repo)
  "Get most recent commit in REPO."
  (s-trim (shell-command-to-string (format "(cd %s; git rev-parse HEAD)" repo))))

(defun upmacs-freeze ()
  "List all packages and their most recent commit."
  (let ((pkgs (f-directories straight-repo-dir)))
    (dolist (pkg pkgs)
      (msg "%s %s" (_get-commit pkg) pkg))))

(if (null argv)
    ;; display usage if called without arguments
    (usage)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ("help" (upmacs-usage))
        ((or "ls" "list") (upmacs-list))
        ((or "rm" "remove") (upmacs-remove))
        ((or "install" "update") (upmacs-update))
        ("update-all" (upmacs-update-all))
        ("freeze" (upmacs-freeze))))))
