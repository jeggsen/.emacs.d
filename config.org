#+TITLE: Emacs 'literal programming' configuration
#+HTML_HEAD: <style>html,body { max-width: 800px; margin-left: auto; margin-right: auto; font-family: sans-serif;}</style>
#+OPTIONS: html-postamble:nil

* Core setup
This sets up the things the rest of the config uses, user credentials,
default directories, etc.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Jens Christian Jensen")
(setq user-mail-address "jensecj+emacs@gmail.com")
#+END_SRC

The directories we're going to use.
#+BEGIN_SRC emacs-lisp
(defconst my-emacs-dir user-emacs-directory)
(defconst my-emacs-lisp-dir (concat my-emacs-dir "lisp/"))
(defconst my-emacs-modes-dir (concat my-emacs-dir "modes/"))
(defconst my-emacs-defuns-dir (concat my-emacs-dir "defuns/"))

(defconst my-emacs-temp-dir (concat my-emacs-dir ".temp/"))
;; config and cache files
(defconst my-emacs-data-dir (concat my-emacs-dir "data/"))
;; backups and auto saves
(defconst my-emacs-backup-dir (concat my-emacs-data-dir "backups/"))
#+END_SRC

Create the directories if they don't already exist.
#+BEGIN_SRC emacs-lisp
(unless (file-exists-p my-emacs-lisp-dir)
  (make-directory my-emacs-lisp-dir))
(unless (file-exists-p my-emacs-modes-dir)
  (make-directory my-emacs-modes-dir))
(unless (file-exists-p my-emacs-defuns-dir)
  (make-directory my-emacs-defuns-dir))

(unless (file-exists-p my-emacs-temp-dir)
  (make-directory my-emacs-temp-dir))
(unless (file-exists-p my-emacs-data-dir)
  (make-directory my-emacs-data-dir))
(unless (file-exists-p my-emacs-backup-dir)
  (make-directory my-emacs-backup-dir))
#+END_SRC

Add user lisp directories to the load path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path my-emacs-lisp-dir)
(add-to-list 'load-path my-emacs-modes-dir)
#+END_SRC

* Defaults
A lot of these settings are single line =(setq ...)= statements,
simply because it makes it convienient to change a single setting on
the run and apply the change.

** Frame
Turn off excess interface early in startup to avoid momentary display
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Better title
(setq frame-title-format "emacs - %b")
#+END_SRC

** Directories used by built-ins
Save temp files in the =.temp= folder
#+BEGIN_SRC emacs-lisp
(setq temporary-file-directory my-emacs-temp-dir)

#+END_SRC

Keep emacs custom settings in a separate file, and load it if it exists.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat my-emacs-dir "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my-emacs-data-dir "bookmarks"))

;; the session persistent cache, used by unicode-fonts, etc.
(setq pcache-directory (concat my-emacs-data-dir "pcache/"))
#+END_SRC

** Backup
Make backups of files, even when they're in version control, and set
how many backups we want to save for each file.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files t
      vc-make-backup-files t
      version-control t
      delete-old-versions t
      kept-old-versions 9
      kept-new-versions 9
      auto-save-default t)
#+END_SRC

Save backup and auto-save files in the =data= folder.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `((".*" . ,my-emacs-backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,my-emacs-backup-dir t)))
(setq auto-save-list-file-prefix my-emacs-backup-dir)
#+END_SRC

** Font setup
Use =Source Code Pro= font if it is available. When launching emacs as a
daemon, fonts are not loaded until we actually produce a frame, so the
font list will be empty, focus-in-hook is run when a frame is created,
whether by a user or a daemon, the first frame created will not have
the setup, as it is created before this is run, still looking into
this.
#+BEGIN_SRC emacs-lisp
(defun init-font-setup ()
  "setup fonts, then remove self from `focus-in-hook'"
  (when (find-font (font-spec :name "Source Code Pro Semibold 10"))
    (add-to-list 'default-frame-alist '(font . "Source Code Pro Semibold 10")))
  (remove-hook 'focus-in-hook 'init-font-setup))

(add-hook 'focus-in-hook 'init-font-setup)
#+END_SRC

** Misc

#+BEGIN_SRC emacs-lisp
;; Hide the splash screen
(setq inhibit-startup-message t)

;; enable useful disabled features
(put 'narrow-to-region 'disabled nil)

;; Don't blink the cursor
(blink-cursor-mode 0)

;; Highlight current line, with a sane color, and transparent foreground
;; (so it does not mess with syntax highlighting)
(global-hl-line-mode 1)
(set-face-background 'hl-line "gray30")
(set-face-foreground 'highlight nil)
(set-face-underline 'highlight nil)

;; Allow pasting selection outside of Emacs
(setq select-enable-clipboard t)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Auto refresh buffers
(global-auto-revert-mode 1)

;; Show keystrokes in progress
(setq echo-keystrokes 0.1)

;; Move files to trash when deleting
(setq delete-by-moving-to-trash t)

;; don't use shift to mark things
(setq shift-select-mode nil)

;; Transparently open compressed files
(auto-compression-mode t)

;; Enable syntax highlighting for older Emacsen that have it off
(global-font-lock-mode t)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; use UTF-8
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; Show active region
(transient-mark-mode 1)

;; Remove text in active region if inserting text
(delete-selection-mode 1)

;; display line and column numbers in mode-line
(setq line-number-mode t)
(setq column-number-mode t)

;; Lines should be 80 characters wide, not 72
(setq-default fill-column 80)

;; Undo/redo window configuration with C-c <left>/<right>
(winner-mode 1)

;; use spaces instead of tabs
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
;; this messes with less things when indenting,
;; tabs are converted to spaces automatically
(setq-default indent-line-function 'insert-tab)

;; Show me empty lines after buffer end
(setq-default indicate-empty-lines t)

;; Easily navigate silly cased words
(global-subword-mode 1)

;; Don't automatically break lines
(setq truncate-lines t)

;; Allow recursive mini buffers
(setq enable-recursive-minibuffers t)

;; Don't be so stingy on the memory, we have lots now. It's the distant future.
(setq gc-cons-threshold 20000000)

;; show everything that's happening when evaluating somethingx
(setq eval-expression-print-level nil)

;; End files in newlines
(setq require-final-newline 't)

;; Save before compiling, dont ask
(setq compilation-ask-about-save nil)

;; save more things in the kill ring
(setq kill-ring-max 200)
#+END_SRC

* Defuns
** Buffers
#+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'imenu)

(defun create-scratch-buffer nil
  "create a new scratch buffer to work in. (could be *scratch* - *scratchX*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (funcall initial-major-mode)))

(defun clean-view ()
  "Creates a scratch buffer, and makes it the only buffer visible."
  (interactive)
  (create-scratch-buffer)
  (delete-other-windows))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the white space content of a buffer.
   Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (indent-region (point-min) (point-max))
  (whitespace-cleanup)
  (message "cleaned up"))
#+END_SRC

** Editing
#+BEGIN_SRC emacs-lisp
(defun open-line-below ()
  "Inserts a line below the current line, indents it, and moves the the
  beginning of that line."
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  "Inserts a line above the current line, indents it, and moves the the
  beginning of that line."
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun smart-line-beginning ()
  "Move point to the beginning of line or beginning of text"
  (interactive)
  (let ((pt (point)))
    (beginning-of-line-text)
    (when (eq pt (point))
      (beginning-of-line))))

(defun kill-to-beginning-of-line ()
  "Kills from <point> to the beginning of the current line."
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

(defun save-region-or-current-line (arg)
  "If a region is active then it is saved to the kill-ring, otherwise the current
line is saved."
  (interactive "P")
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (copy-line arg)))

(defun kill-region-or-current-line (arg)
  "If a region is active then it is killed, otherwise the current line is killed."
  (interactive "P")
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (save-excursion
      (kill-whole-line arg))))

(defun join-region ()
  "Join all lines in a region into a single line."
  (interactive)
  (save-excursion
    (let ((beg (region-beginning))
          (end (copy-marker (region-end))))
      (goto-char beg)
      (while (< (point) end)
        (progn
          (join-line 1)
          (end-of-line))))))

(defun wrap-region (b e text-begin text-end)
  "Surrounds region with given text."
  (interactive "r\nsStart text: \nsEnd text: ")
  (if (use-region-p)
      (save-restriction
        (narrow-to-region b e)
        (goto-char (point-max))
        (insert text-end)
        (goto-char (point-min))
        (insert text-begin))
    (message "wrap-region: Error! invalid region!")))
#+END_SRC

** Files
#+BEGIN_SRC emacs-lisp
(defun file-age (file)
  "Returns the number of seconds since the file was last modified."
  (float-time
   (time-subtract (current-time)
                  (nth 5 (file-attributes (file-truename file))))))

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "no such file exists")
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defun touch-buffer-file ()
  "Touches the current buffer, marking it as dirty."
  (interactive)
  (insert " ")
  (backward-delete-char 1)
  (save-buffer))
#+END_SRC

** Lisp
#+BEGIN_SRC emacs-lisp
(defun one-shot-keybinding (key command)
  "Set a keybinding that disappear once you press a key that is not in
the overlay-map"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd key) command)
     map) t))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defmacro with-supressed-message (&rest body)
  "Saves the current message in the minibuffer, executes body, then
restores the message."
  (let ((saved-message-symbol (make-symbol "saved-message")))
    `(let ((,saved-message-symbol (current-message)))
       (progn ,@body)
       (message ,saved-message-symbol))))

(defun save-to-file (data filename)
  "Save lisp object to a file"
  (with-temp-file filename
    (prin1 data (current-buffer))))

(defun load-from-file (filename)
  "Load lisp object from file"
  (with-temp-buffer
    (insert-file-contents filename)
    (cl-assert (eq (point) (point-min)))
    (read (current-buffer))))
#+END_SRC

** Packages
#+BEGIN_SRC emacs-lisp
(defun counsel-read-file-name (prompt &optional initial-input)
  "Query for a file path using counsel and ivy"
  (interactive)
  (ivy-read prompt 'read-file-name-internal
            :matcher #'counsel--find-file-matcher
            :initial-input initial-input
            :action
            (lambda (x)
              (with-ivy-window
                (if (and counsel-find-file-speedup-remote
                         (file-remote-p ivy--directory))
                    (let ((find-file-hook nil))
                      (expand-file-name x ivy--directory))
                  (expand-file-name x ivy--directory))))
            :preselect (when counsel-find-file-at-point
                         (require 'ffap)
                         (let ((f (ffap-guesser)))
                           (when f (expand-file-name f))))
            :require-match 'confirm-after-completion
            :history 'file-name-history
            :keymap counsel-find-file-map
            :caller 'counsel-read-find-name))

(require 's)
(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  ;; only kill the buffer if it's the actual buffer, this way we can
  ;; still get back to our previous configuration if we quit magit weirdly
  (if (s-prefix? "*magit:" (buffer-name (current-buffer)))
      (kill-buffer))
  (jump-to-register :magit-fullscreen))
#+END_SRC

** Windows
#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  "Toggle window splitting between horizontal and vertical"
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))
    (message "You can only toggle split of two windows!")))

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* ((w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2)))
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

;; intuitive window resizing
(defun xor (b1 b2)
  (or (and b1 b2)
      (and (not b1) (not b2))))

(defun move-border-left-or-right (arg dir)
  "General function covering move-border-left and move-border-right.
   If DIR is t, then move left, otherwise move right."
  (interactive)
  (if (null arg) (setq arg 3))
  (let ((left-edge (nth 0 (window-edges))))
    (if (xor (= left-edge 0) dir)
        (shrink-window arg t)
      (enlarge-window arg t))))

(defun move-border-up-or-down (arg dir)
  "General function covering move-border-up and move-border-down.
   If DIR is t, then move up, otherwise move down."
  (interactive)
  (if (null arg) (setq arg 3))
  (let ((top-edge (nth 1 (window-edges))))
    (if (xor (= top-edge 0) dir)
        (shrink-window arg nil)
      (enlarge-window arg nil))))

(defun move-border-left (arg)
  (interactive "P")
  (move-border-left-or-right arg t))

(defun move-border-right (arg)
  (interactive "P")
  (move-border-left-or-right arg nil))

(defun move-border-up (arg)
  (interactive "P")
  (move-border-up-or-down arg t))

(defun move-border-down (arg)
  (interactive "P")
  (move-border-up-or-down arg nil))
#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
(defmacro create-simple-keybinding-command (name key)
  `(defmacro ,name (&rest fns)
     (list 'global-set-key (kbd ,key) `(lambda ()
                                         (interactive)
                                         ,@fns))))

(create-simple-keybinding-command f2 "<f2>")
(create-simple-keybinding-command f5 "<f5>")
(create-simple-keybinding-command f6 "<f6>")
(create-simple-keybinding-command f7 "<f7>")
(create-simple-keybinding-command f8 "<f8>")
(create-simple-keybinding-command f9 "<f9>")
(create-simple-keybinding-command f10 "<f10>")
(create-simple-keybinding-command f11 "<f11>")
(create-simple-keybinding-command f12 "<f12>")

(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))

;; format linum mode, makes if readable, but uses some space, fine since it
;; is only visible when using =goto-line-with-feedback=.
(setq linum-format (lambda (line)
                     (propertize
                      (format (concat " %"
                                      (number-to-string
                                       (length (number-to-string
                                                (line-number-at-pos (point-max)))))
                                      "d ")
                              line)
                      'face 'linum)))


#+END_SRC

* Use-packages
#+BEGIN_SRC emacs-lisp
;; give buffers unique names
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward))

(use-package tramp
  :config
  (setq tramp-persistency-file-name (concat my-emacs-data-dir "tramp")))

;; Save point position between sessions
(use-package saveplace
  :config
  (setq-default save-place t)
  (setq save-place-file (concat my-emacs-data-dir "saveplaces")))

;; Persist some vars across sessions
(use-package savehist
  :config
  (setq savehist-file (concat my-emacs-data-dir "savehist"))
  (setq savehist-autosave-interval 60) ;; save every minute
  (setq savehist-additional-variables '(search-ring
                                        regexp-search-ring))
  (savehist-mode 1))

;; Save a list of recently visited files.
(use-package recentf
  :config
  (setq recentf-save-file (recentf-expand-file-name (concat my-emacs-data-dir "recentf")))
  (setq recentf-exclude '(".emacs.d/elpa/" ".emacs.d/data/"))
  (setq recentf-max-saved-items 500) ;; just 20 is too few
  (setq recentf-auto-cleanup 300) ;; cleanup every 5 mins.
  ;; save recentf file every 30s, but don't bother us about it
  (setq recentf-auto-save-timer
        (run-with-idle-timer 30 t '(lambda ()
                                     (with-supressed-message (recentf-save-list)))))
  (recentf-mode 1))

#+END_SRC

* Package specific things
* Advices and Hooks
When popping the mark, continue popping until the cursor actually
moves. also, if the last command was a copy - skip past all the
expand-region cruft.
#+BEGIN_SRC emacs-lisp
(defadvice pop-to-mark-command (around ensure-new-position activate)
  (let ((p (point)))
    (when (eq last-command 'save-region-or-current-line)
      ad-do-it
      ad-do-it
      ad-do-it)
    (dotimes (i 10)
      (when (= p (point)) ad-do-it))))
#+END_SRC

Create nonexistent directories when saving a file
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (not (file-exists-p dir))
                  (make-directory dir t))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice magit-status (around magit-fullscreen activate)
  "Saves window configuration, then opens magit in fullscreen"
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defadvice undo-tree-undo (around keep-region activate)
  "Keep the region when undoing inside region"
  (if (use-region-p)
      (let ((m (set-marker (make-marker) (mark)))
            (p (set-marker (make-marker) (point))))
        ad-do-it
        (goto-char p)
        (set-mark m)
        (set-marker p nil)
        (set-marker m nil))
    ad-do-it))

(defun my-counsel-grep-or-swiper (orig-fun &rest args)
  "Start searching with the region as initial input"
  (if (region-active-p)
      (let ((start (region-beginning))
            (end (region-end)))
        (deactivate-mark)
        (apply orig-fun (list (buffer-substring-no-properties start end))))
    (funcall orig-fun)))

(advice-add 'counsel-grep-or-swiper :around #'my-counsel-grep-or-swiper)

(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(advice-add 'dired-readin :after #'mydired-sort)
#+END_SRC

* Keybindings

* tty

* Homemade modes

* Experimental

* Epilogue
#+BEGIN_SRC emacs-lisp
(message "done loading init org file")
#+END_SRC
