#+TITLE: Emacs 'literal programming' configuration
#+HTML_HEAD: <style>html,body { max-width: 800px; margin-left: auto; margin-right: auto; font-family: sans-serif;}</style>
#+OPTIONS: html-postamble:nil

* Core setup
This sets up the things the rest of the config uses, user credentials,
default directories, etc.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Jens Christian Jensen")
(setq user-mail-address "jensecj+emacs@gmail.com")
#+END_SRC

The directories we're going to use.
#+BEGIN_SRC emacs-lisp
(defconst my-emacs-dir user-emacs-directory)
(defconst my-emacs-lisp-dir (concat my-emacs-dir "lisp/"))
(defconst my-emacs-modes-dir (concat my-emacs-dir "modes/"))
(defconst my-emacs-defuns-dir (concat my-emacs-dir "defuns/"))

(defconst my-emacs-temp-dir (concat my-emacs-dir ".temp/"))
;; config and cache files
(defconst my-emacs-data-dir (concat my-emacs-dir "data/"))
;; backups and auto saves
(defconst my-emacs-backup-dir (concat my-emacs-data-dir "backups/"))
#+END_SRC

Create the directories if they don't already exist.
#+BEGIN_SRC emacs-lisp
(unless (file-exists-p my-emacs-lisp-dir)
  (make-directory my-emacs-lisp-dir))
(unless (file-exists-p my-emacs-modes-dir)
  (make-directory my-emacs-modes-dir))
(unless (file-exists-p my-emacs-defuns-dir)
  (make-directory my-emacs-defuns-dir))

(unless (file-exists-p my-emacs-temp-dir)
  (make-directory my-emacs-temp-dir))
(unless (file-exists-p my-emacs-data-dir)
  (make-directory my-emacs-data-dir))
(unless (file-exists-p my-emacs-backup-dir)
  (make-directory my-emacs-backup-dir))
#+END_SRC

Add user lisp directories to the load path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path my-emacs-lisp-dir)
(add-to-list 'load-path my-emacs-modes-dir)
#+END_SRC

* Defaults
A lot of these settings are single line =(setq ...)= statements,
simply because it makes it convienient to change a single setting on
the run and apply the change.

** Frame
Turn off excess interface early in startup to avoid momentary display
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Better title
(setq frame-title-format "emacs - %b")
#+END_SRC

** Directories used by built-ins
Save temp files in the =.temp= folder
#+BEGIN_SRC emacs-lisp
(setq temporary-file-directory my-emacs-temp-dir)

#+END_SRC

Keep emacs custom settings in a separate file, and load it if it exists.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat my-emacs-dir "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my-emacs-data-dir "bookmarks"))

;; the session persistent cache, used by unicode-fonts, etc.
(setq pcache-directory (concat my-emacs-data-dir "pcache/"))
#+END_SRC

** Backup
Make backups of files, even when they're in version control, and set
how many backups we want to save for each file.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files t
      vc-make-backup-files t
      version-control t
      delete-old-versions t
      kept-old-versions 9
      kept-new-versions 9
      auto-save-default t)
#+END_SRC

Save backup and auto-save files in the =data= folder.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `((".*" . ,my-emacs-backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,my-emacs-backup-dir t)))
(setq auto-save-list-file-prefix my-emacs-backup-dir)
#+END_SRC

** Font setup
Use =Source Code Pro= font if it is available. When launching emacs as a
daemon, fonts are not loaded until we actually produce a frame, so the
font list will be empty, focus-in-hook is run when a frame is created,
whether by a user or a daemon, the first frame created will not have
the setup, as it is created before this is run, still looking into
this.
#+BEGIN_SRC emacs-lisp
(defun init-font-setup ()
  "setup fonts, then remove self from `focus-in-hook'"
  (when (find-font (font-spec :name "Source Code Pro Semibold 10"))
    (add-to-list 'default-frame-alist '(font . "Source Code Pro Semibold 10")))
  (remove-hook 'focus-in-hook 'init-font-setup))

(add-hook 'focus-in-hook 'init-font-setup)
#+END_SRC

** Misc

#+BEGIN_SRC emacs-lisp
;; Hide the splash screen
(setq inhibit-startup-message t)

;; enable useful disabled features
(put 'narrow-to-region 'disabled nil)

;; Don't blink the cursor
(blink-cursor-mode 0)

;; Highlight current line, with a sane color, and transparent foreground
;; (so it does not mess with syntax highlighting)
(global-hl-line-mode 1)
(set-face-background 'hl-line "gray30")
(set-face-foreground 'highlight nil)
(set-face-underline 'highlight nil)

;; Allow pasting selection outside of Emacs
(setq select-enable-clipboard t)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Auto refresh buffers
(global-auto-revert-mode 1)

;; Show keystrokes in progress
(setq echo-keystrokes 0.1)

;; Move files to trash when deleting
(setq delete-by-moving-to-trash t)

;; don't use shift to mark things
(setq shift-select-mode nil)

;; Transparently open compressed files
(auto-compression-mode t)

;; Enable syntax highlighting for older Emacsen that have it off
(global-font-lock-mode t)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; use UTF-8
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; Show active region
(transient-mark-mode 1)

;; Remove text in active region if inserting text
(delete-selection-mode 1)

;; display line and column numbers in mode-line
(setq line-number-mode t)
(setq column-number-mode t)

;; Lines should be 80 characters wide, not 72
(setq-default fill-column 80)

;; Undo/redo window configuration with C-c <left>/<right>
(winner-mode 1)

;; use spaces instead of tabs
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
;; this messes with less things when indenting,
;; tabs are converted to spaces automatically
(setq-default indent-line-function 'insert-tab)

;; Show me empty lines after buffer end
(setq-default indicate-empty-lines t)

;; Easily navigate silly cased words
(global-subword-mode 1)

;; Don't automatically break lines
(setq truncate-lines t)

;; Allow recursive mini buffers
(setq enable-recursive-minibuffers t)

;; Don't be so stingy on the memory, we have lots now. It's the distant future.
(setq gc-cons-threshold 20000000)

;; show everything that's happening when evaluating somethingx
(setq eval-expression-print-level nil)

;; End files in newlines
(setq require-final-newline 't)

;; Save before compiling, dont ask
(setq compilation-ask-about-save nil)

;; save more things in the kill ring
(setq kill-ring-max 200)
#+END_SRC

* Defuns
** Buffers
#+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'imenu)

(defun create-scratch-buffer nil
  "create a new scratch buffer to work in. (could be *scratch* - *scratchX*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (emacs-lisp-mode)))

(defun clean-view ()
  "Creates a scratch buffer, and makes it the only buffer visible."
  (interactive)
  (create-scratch-buffer)
  (delete-other-windows))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the white space content of a buffer.
   Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (indent-region (point-min) (point-max))
  (whitespace-cleanup)
  (message "cleaned up"))
#+END_SRC

** Editing
#+BEGIN_SRC emacs-lisp
(defun open-line-below ()
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun new-line-in-between ()
  (interactive)
  (newline)
  (save-excursion
    (newline)
    (indent-for-tab-command))
  (indent-for-tab-command))

(defun smart-line-beginning ()
  "Move point to the beginning of line or beginning of text"
  (interactive)
  (let ((pt (point)))
    (beginning-of-line-text)
    (when (eq pt (point))
      (beginning-of-line))))

(defun kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word 1)))

(defun kill-to-beginning-of-line ()
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

(defun copy-to-end-of-line ()
  (interactive)
  (kill-ring-save (point)
                  (line-end-position))
  (message "Copied to end of line"))

(defun copy-whole-lines (arg)
  "Copy lines (as many as prefix argument) in the kill ring"
  (interactive "p")
  (kill-ring-save (line-beginning-position)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(defun copy-line (arg)
  "Copy to end of line, or as many lines as prefix argument"
  (interactive "P")
  (if (null arg)
      (copy-whole-lines 1)
    (copy-whole-lines (prefix-numeric-value arg))))

(defun save-region-or-current-line (arg)
  (interactive "P")
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (copy-line arg)))

(defun kill-region-or-current-line (arg)
  (interactive "P")
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (save-excursion
      (kill-whole-line arg))))

(defun kill-and-retry-line ()
  "Kill the entire current line and reposition point at indentation"
  (interactive)
  (back-to-indentation)
  (kill-line))

(defun comment-kill-all ()
  "kill all comments in buffer"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (comment-kill (save-excursion
                    (goto-char (point-max))
                    (line-number-at-pos)))))

(defun join-region ()
  "join all lines in a region"
  (interactive)
  (save-excursion
    (let ((beg (region-beginning))
          (end (copy-marker (region-end))))
      (goto-char beg)
      (while (< (point) end)
        (progn
          (join-line 1)
          (end-of-line))))))

(defun wrap-region (b e text-begin text-end)
  "Surround current region with given text."
  (interactive "r\nsStart text: \nsEnd text: ")
  (if (use-region-p)
      (save-restriction
        (narrow-to-region b e)
        (goto-char (point-max))
        (insert text-end)
        (goto-char (point-min))
        (insert text-begin))
    (message "wrap-region: Error! invalid region!")))
#+END_SRC

** Files
** Lisp
#+BEGIN_SRC emacs-lisp
(defun one-shot-keybinding (key command)
  "set keybindings that disappear once you press a key that is not in
the overlay-map"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd key) command)
     map) t))
#+END_SRC

** Packages
** Windows
#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  "Toggle window splitting between horizontal and vertical"
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))
    (message "You can only toggle split of two windows!")))

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* ((w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2)))
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))
#+END_SRC
** Misc
* Advices and Hooks

When popping the mark, continue popping until the cursor actually
moves. also, if the last command was a copy - skip past all the
expand-region cruft.
#+BEGIN_SRC emacs-lisp
(defadvice pop-to-mark-command (around ensure-new-position activate)
  (let ((p (point)))
    (when (eq last-command 'save-region-or-current-line)
      ad-do-it
      ad-do-it
      ad-do-it)
    (dotimes (i 10)
      (when (= p (point)) ad-do-it))))
#+END_SRC

Create nonexistent directories when saving a file
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (not (file-exists-p dir))
                  (make-directory dir t))))))
#+END_SRC

* Use-packages
#+BEGIN_SRC emacs-lisp
;; give buffers unique names
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward))

(use-package tramp
  :config
  (setq tramp-persistency-file-name (concat my-emacs-data-dir "tramp")))

;; Save point position between sessions
(use-package saveplace
  :config
  (setq-default save-place t)
  (setq save-place-file (concat my-emacs-data-dir "saveplaces")))

;; Persist some vars across sessions
(use-package savehist
  :config
  (setq savehist-file (concat my-emacs-data-dir "savehist"))
  (setq savehist-autosave-interval 60) ;; save every minute
  (setq savehist-additional-variables '(search-ring
                                        regexp-search-ring))
  (savehist-mode 1))

;; Save a list of recently visited files.
(use-package recentf
  :config
  (setq recentf-save-file (recentf-expand-file-name (concat my-emacs-data-dir "recentf")))
  (setq recentf-exclude '(".emacs.d/elpa/" ".emacs.d/data/"))
  (setq recentf-max-saved-items 500) ;; just 20 is too few
  (setq recentf-auto-cleanup 300) ;; cleanup every 5 mins.
  ;; save recentf file every 30s, but don't bother us about it
  (setq recentf-auto-save-timer
        (run-with-idle-timer 30 t '(lambda ()
                                     (with-supressed-message (recentf-save-list)))))
  (recentf-mode 1))

#+END_SRC

* Package specific things

* Keybindings

* tty

* Homemade modes

* Experimental

* Epilogue
#+BEGIN_SRC emacs-lisp
(message "done loading init org file")
#+END_SRC
