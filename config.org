#+TITLE: Emacs 'literal programming' configuration
#+HTML_HEAD: <style>html,body { max-width: 800px; margin-left: auto; margin-right: auto; font-family: sans-serif;}</style>
#+OPTIONS: html-postamble:nil

* Core setup
This sets up the things the rest of the config uses, user credentials,
default directories, etc.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Jens Christian Jensen")
(setq user-mail-address "jensecj+emacs@gmail.com")
#+END_SRC

The directories we're going to use.
#+BEGIN_SRC emacs-lisp
(defconst my-emacs-dir user-emacs-directory)
(defconst my-emacs-lisp-dir (concat my-emacs-dir "lisp/"))
(defconst my-emacs-modes-dir (concat my-emacs-dir "modes/"))
(defconst my-emacs-defuns-dir (concat my-emacs-dir "defuns/"))

(defconst my-emacs-temp-dir (concat my-emacs-dir ".temp/"))
;; config and cache files
(defconst my-emacs-data-dir (concat my-emacs-dir "data/"))
;; backups and auto saves
(defconst my-emacs-backup-dir (concat my-emacs-data-dir "backups/"))
#+END_SRC

Create the directories if they don't already exist.
#+BEGIN_SRC emacs-lisp
(unless (file-exists-p my-emacs-lisp-dir)
  (make-directory my-emacs-lisp-dir))
(unless (file-exists-p my-emacs-modes-dir)
  (make-directory my-emacs-modes-dir))
(unless (file-exists-p my-emacs-defuns-dir)
  (make-directory my-emacs-defuns-dir))

(unless (file-exists-p my-emacs-temp-dir)
  (make-directory my-emacs-temp-dir))
(unless (file-exists-p my-emacs-data-dir)
  (make-directory my-emacs-data-dir))
(unless (file-exists-p my-emacs-backup-dir)
  (make-directory my-emacs-backup-dir))
#+END_SRC

Add user lisp directories to the load path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path my-emacs-lisp-dir)
(add-to-list 'load-path my-emacs-modes-dir)
#+END_SRC

Setup package archives
#+BEGIN_SRC emacs-lisp
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))

(defconst melpa-archive (concat my-emacs-dir "elpa/archives/melpa"))
#+END_SRC

Some includes that a lot of things use
#+BEGIN_SRC emacs-lisp
(require 'cl)

#+END_SRC

* Defaults
A lot of these settings are single line =(setq ...)= statements,
simply because it makes it convienient to change a single setting on
the run and apply the change.

** Frame
Turn off excess interface early in startup to avoid momentary display
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Better title
(setq frame-title-format "emacs - %b")
#+END_SRC

** Directories used by built-ins
Save temp files in the =.temp= folder
#+BEGIN_SRC emacs-lisp
(setq temporary-file-directory my-emacs-temp-dir)

#+END_SRC

Keep emacs custom settings in a separate file, and load it if it exists.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat my-emacs-dir "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat my-emacs-data-dir "bookmarks"))

;; the session persistent cache, used by unicode-fonts, etc.
(setq pcache-directory (concat my-emacs-data-dir "pcache/"))
#+END_SRC

** Backup
Make backups of files, even when they're in version control, and set
how many backups we want to save for each file.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files t
      vc-make-backup-files t
      version-control t
      delete-old-versions t
      kept-old-versions 9
      kept-new-versions 9
      auto-save-default t)
#+END_SRC

Save backup and auto-save files in the =data= folder.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `((".*" . ,my-emacs-backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,my-emacs-backup-dir t)))
(setq auto-save-list-file-prefix my-emacs-backup-dir)
#+END_SRC

** Font setup
Use =Source Code Pro= font if it is available. When launching emacs as a
daemon, fonts are not loaded until we actually produce a frame, so the
font list will be empty, focus-in-hook is run when a frame is created,
whether by a user or a daemon, the first frame created will not have
the setup, as it is created before this is run, still looking into
this.
#+BEGIN_SRC emacs-lisp
(defun init-font-setup ()
  "setup fonts, then remove self from `focus-in-hook'"
  (when (find-font (font-spec :name "Source Code Pro Semibold 10"))
    (add-to-list 'default-frame-alist '(font . "Source Code Pro Semibold 10")))
  (remove-hook 'focus-in-hook 'init-font-setup))

(add-hook 'focus-in-hook 'init-font-setup)
#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
;; Hide the splash screen
(setq inhibit-startup-message t)

;; set the paranoia level to medium, warns if connections are insecure
(setq network-security-level 'medium)

;; enable useful disabled features
(put 'narrow-to-region 'disabled nil)

;; Don't blink the cursor
(blink-cursor-mode 0)

;; Highlight current line, with a sane color, and transparent foreground
;; (so it does not mess with syntax highlighting)
(global-hl-line-mode 1)
(set-face-background 'hl-line "gray30")
(set-face-foreground 'highlight nil)
(set-face-underline 'highlight nil)

;; Allow pasting selection outside of Emacs
(setq select-enable-clipboard t)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Auto refresh buffers
(global-auto-revert-mode 1)

;; Show keystrokes in progress
(setq echo-keystrokes 0.1)

;; Move files to trash when deleting
(setq delete-by-moving-to-trash t)

;; don't use shift to mark things
(setq shift-select-mode nil)

;; Transparently open compressed files
(auto-compression-mode t)

;; Enable syntax highlighting for older Emacsen that have it off
(global-font-lock-mode t)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; use UTF-8
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; Show active region
(transient-mark-mode 1)

;; Remove text in active region if inserting text
(delete-selection-mode 1)

;; display line and column numbers in mode-line
(setq line-number-mode t)
(setq column-number-mode t)

;; Lines should be 80 characters wide, not 72
(setq-default fill-column 80)

;; Undo/redo window configuration with C-c <left>/<right>
(winner-mode 1)

;; use spaces instead of tabs
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
;; this messes with less things when indenting,
;; tabs are converted to spaces automatically
(setq-default indent-line-function 'insert-tab)

;; Show me empty lines after buffer end
(setq-default indicate-empty-lines t)

;; Easily navigate silly cased words
(global-subword-mode 1)

;; Don't automatically break lines
(setq truncate-lines t)

;; Allow recursive mini buffers
(setq enable-recursive-minibuffers t)

;; Don't be so stingy on the memory, we have lots now. It's the distant future.
(setq gc-cons-threshold 20000000)

;; show everything that's happening when evaluating somethingx
(setq eval-expression-print-level nil)

;; End files in newlines
(setq require-final-newline 't)

;; Save before compiling, dont ask
(setq compilation-ask-about-save nil)

;; save more things in the kill ring
(setq kill-ring-max 200)
#+END_SRC

* Defuns
** Buffers
#+BEGIN_SRC emacs-lisp
(require 'imenu)

(defun create-scratch-buffer nil
  "create a new scratch buffer to work in. (could be *scratch* - *scratchX*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (funcall initial-major-mode)))

(defun clean-view ()
  "Creates a scratch buffer, and makes it the only buffer visible."
  (interactive)
  (create-scratch-buffer)
  (delete-other-windows))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the white space content of a buffer.
   Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (indent-region (point-min) (point-max))
  (whitespace-cleanup)
  (message "cleaned up"))
#+END_SRC

** Editing
#+BEGIN_SRC emacs-lisp
(defun open-line-below ()
  "Inserts a line below the current line, indents it, and moves the the
  beginning of that line."
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  "Inserts a line above the current line, indents it, and moves the the
  beginning of that line."
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun smart-line-beginning ()
  "Move point to the beginning of line or beginning of text"
  (interactive)
  (let ((pt (point)))
    (beginning-of-line-text)
    (when (eq pt (point))
      (beginning-of-line))))

(defun kill-to-beginning-of-line ()
  "Kills from <point> to the beginning of the current line."
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

(defun save-region-or-current-line (arg)
  "If a region is active then it is saved to the kill-ring, otherwise the current
line is saved."
  (interactive "P")
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (kill-ring-save (line-beginning-position) (line-end-position))))

(defun kill-region-or-current-line (arg)
  "If a region is active then it is killed, otherwise the current line is killed."
  (interactive "P")
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (save-excursion
      (kill-whole-line arg))))

(defun join-region ()
  "Join all lines in a region into a single line."
  (interactive)
  (save-excursion
    (let ((beg (region-beginning))
          (end (copy-marker (region-end))))
      (goto-char beg)
      (while (< (point) end)
        (progn
          (join-line 1)
          (end-of-line))))))

(defun wrap-region (b e text-begin text-end)
  "Surrounds region with given text."
  (interactive "r\nsStart text: \nsEnd text: ")
  (if (use-region-p)
      (save-restriction
        (narrow-to-region b e)
        (goto-char (point-max))
        (insert text-end)
        (goto-char (point-min))
        (insert text-begin))
    (message "wrap-region: Error! invalid region!")))
#+END_SRC

** Files
#+BEGIN_SRC emacs-lisp
(defun file-age (file)
  "Returns the number of seconds since the file was last modified."
  (float-time
   (time-subtract (current-time)
                  (nth 5 (file-attributes (file-truename file))))))

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "no such file exists")
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defun touch-buffer-file ()
  "Touches the current buffer, marking it as dirty."
  (interactive)
  (insert " ")
  (backward-delete-char 1)
  (save-buffer))
#+END_SRC

** Lisp
#+BEGIN_SRC emacs-lisp
(defun one-shot-keybinding (key command)
  "Set a keybinding that disappear once you press a key that is not in
the overlay-map"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd key) command)
     map) t))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defmacro with-supressed-message (&rest body)
  "Saves the current message in the minibuffer, executes body, then
restores the message."
  (let ((saved-message-symbol (make-symbol "saved-message")))
    `(let ((,saved-message-symbol (current-message)))
       (progn ,@body)
       (message ,saved-message-symbol))))

(defun save-to-file (data filename)
  "Save lisp object to a file"
  (with-temp-file filename
    (prin1 data (current-buffer))))

(defun load-from-file (filename)
  "Load lisp object from file"
  (with-temp-buffer
    (insert-file-contents filename)
    (cl-assert (eq (point) (point-min)))
    (read (current-buffer))))
#+END_SRC

** Packages
#+BEGIN_SRC emacs-lisp
(defun counsel-read-file-name (prompt &optional initial-input)
  "Query for a file path using counsel and ivy"
  (interactive)
  (ivy-read prompt 'read-file-name-internal
            :matcher #'counsel--find-file-matcher
            :initial-input initial-input
            :action
            (lambda (x)
              (with-ivy-window
                (if (and counsel-find-file-speedup-remote
                         (file-remote-p ivy--directory))
                    (let ((find-file-hook nil))
                      (expand-file-name x ivy--directory))
                  (expand-file-name x ivy--directory))))
            :preselect (when counsel-find-file-at-point
                         (require 'ffap)
                         (let ((f (ffap-guesser)))
                           (when f (expand-file-name f))))
            :require-match 'confirm-after-completion
            :history 'file-name-history
            :keymap counsel-find-file-map
            :caller 'counsel-read-find-name))

(require 's)
(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  ;; only kill the buffer if it's the actual buffer, this way we can
  ;; still get back to our previous configuration if we quit magit weirdly
  (if (s-prefix? "*magit:" (buffer-name (current-buffer)))
      (kill-buffer))
  (jump-to-register :magit-fullscreen))
#+END_SRC

** Windows
#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  "Toggle window splitting between horizontal and vertical"
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))
    (message "You can only toggle split of two windows!")))

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* ((w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2)))
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

;; intuitive window resizing
(defun xor (b1 b2)
  (or (and b1 b2)
      (and (not b1) (not b2))))

(defun move-border-left-or-right (arg dir)
  "General function covering move-border-left and move-border-right.
   If DIR is t, then move left, otherwise move right."
  (interactive)
  (if (null arg) (setq arg 3))
  (let ((left-edge (nth 0 (window-edges))))
    (if (xor (= left-edge 0) dir)
        (shrink-window arg t)
      (enlarge-window arg t))))

(defun move-border-up-or-down (arg dir)
  "General function covering move-border-up and move-border-down.
   If DIR is t, then move up, otherwise move down."
  (interactive)
  (if (null arg) (setq arg 3))
  (let ((top-edge (nth 1 (window-edges))))
    (if (xor (= top-edge 0) dir)
        (shrink-window arg nil)
      (enlarge-window arg nil))))

(defun move-border-left (arg)
  (interactive "P")
  (move-border-left-or-right arg t))

(defun move-border-right (arg)
  (interactive "P")
  (move-border-left-or-right arg nil))

(defun move-border-up (arg)
  (interactive "P")
  (move-border-up-or-down arg t))

(defun move-border-down (arg)
  (interactive "P")
  (move-border-up-or-down arg nil))
#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
(defmacro create-simple-keybinding-command (name key)
  `(defmacro ,name (&rest fns)
     (list 'global-set-key (kbd ,key) `(lambda ()
                                         (interactive)
                                         ,@fns))))

(create-simple-keybinding-command f2 "<f2>")
(create-simple-keybinding-command f5 "<f5>")
(create-simple-keybinding-command f6 "<f6>")
(create-simple-keybinding-command f7 "<f7>")
(create-simple-keybinding-command f8 "<f8>")
(create-simple-keybinding-command f9 "<f9>")
(create-simple-keybinding-command f10 "<f10>")
(create-simple-keybinding-command f11 "<f11>")
(create-simple-keybinding-command f12 "<f12>")

(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))

;; format linum mode, makes if readable, but uses some space, fine since it
;; is only visible when using =goto-line-with-feedback=.
(setq linum-format (lambda (line)
                     (propertize
                      (format (concat " %"
                                      (number-to-string
                                       (length (number-to-string
                                                (line-number-at-pos (point-max)))))
                                      "d ")
                              line)
                      'face 'linum)))


#+END_SRC

* Package installation
#+BEGIN_SRC emacs-lisp
(message (format "= \e[1m\e[32mStarted Package Installation\e[0m"))
#+END_SRC

If the package cache does not exist, or if it is older than a week, refresh it's
content.
#+BEGIN_SRC emacs-lisp
(if (or (not (file-exists-p melpa-archive)) ;; if there exists no archive cache
        (> (file-age melpa-archive) 604800)) ;; or if the cache is old (a week = 60s * 60m * 24h * 7d)
    (package-refresh-contents)) ;; update the package archive cache
#+END_SRC

Some helpers we need to install packages from the package archive.
#+BEGIN_SRC emacs-lisp
(defun install-packages (packages)
  "Install a list of packages, skip packages that are already installed."
  (mapc (lambda (package)
          (unless (package-installed-p package)
            (package-install package)))
        packages))

(defun is-online? ()
  "Returns a non-nil value if we have a network connection."
  (if (and (functionp 'network-interface-list)
           (network-interface-list))
      (some (lambda (iface) (unless (equal "lo" (car iface))
                              (member 'up (first (last (network-interface-info
                                                        (car iface)))))))
            (network-interface-list))
    t))
#+END_SRC

Install packages if we are online, this only installs packages that are not
already installed. Update packages through the package manager using =(list-packages)=.
#+BEGIN_SRC emacs-lisp
(when (is-online?)
  (install-packages
   '(
     ;; libraries
     dash                    ; list functions library (-map, -fold, etc.)
     s                       ; string manipulation library (concat, etc.)
     f                       ; for working with files

     ;; file modes
     ;; auctex                  ; latex
     cmake-mode              ; CMake
     dockerfile-mode         ; dockerfiles
     gitconfig-mode          ; git config files
     gitignore-mode          ; git ignore files
     haskell-mode            ; haskell
     lua-mode                ; lua
     markdown-mode           ; markdown
     rust-mode               ; rust
     scss-mode               ; sassy css
     tuareg                  ; ocaml
     yaml-mode               ; yaml/yml

     ;; programming language specific
     ;; ac-c-headers            ; auto-complete source for c/c++ header files
     ;; ac-clang                ; auto-complete source for clang
     ;; ac-octave               ; auto-complete source for octave
     ac-rtags                ; auto-complate source for rtags
     auto-complete           ; the auto completion framework
     ;; auto-complete-auctex    ; auto-complete source for auctex
     chicken-scheme          ; extensions for scheme code
     clang-format            ; buffer cleanup using clang-format
     rtags                   ; tags for c++ using clang
     scheme-complete         ; auto-completion for scheme

     ;; project / workflow related
     counsel-projectile      ; rewritten projectile function using ivy
     persp-mode              ; group buffers together into perspectives (and their configurations)
     projectile              ; project based behaviours (based on .git/.svn/etc.)
     workgroups              ; required for persp-mode to save perspectives to file

     ;; general emacs things
     org                     ; org-mode
     htmlize                 ; highlight org-mode codeblocks when exporting
     ace-jump-buffer         ; jump between buffers
     ace-jump-mode           ; jump around the buffer with ease
     ace-jump-zap            ; zap-to-char in ace-jump style
     beginend                ; better M-< and M-> (beginning/end of buffer jumps)
     browse-kill-ring        ; browse the kill ring
     change-inner            ; easily change the inner or outer content of something
     counsel                 ; functions rewritten with ivy
     delight                 ; change mode names in the mode-line, works with use-package
     diminish                ; unclutter the mode line (hide modes)
     dired+                  ; more dired features
     ;; el-get                  ; more package management, has the coq proofgeneral package
     exec-path-from-shell    ; grab env variables from outside emacs
     expand-region           ; easily expand/contract selections
     fill-column-indicator   ; line to indicate the fill column
     flx                     ; flexible(fuzzy) matching for completions
     flycheck                ; linting
     git-gutter+             ; mark added/changes/removed lines in the gutter
     git-timemachine         ; easily check file changes through commits
     goto-chg                ; go to last change
     ivy                     ; a new type of completion, ala ido
     jist                    ; manage github gists from emacs
     kurecolor               ; manipulate color strings by hue / contrast / brightness
     magit                   ; magical git interface for emacs
     move-text               ; easily move lines up/down
     multi-term              ; manage multiple terminals
     multiple-cursors        ; ability to use a lot of cursors
     powerline               ; vim-esque powerline
     rainbow-mode            ; color hex strings
     smartparens             ; automatically add end parens, highlight matching parens
     smex                    ; better M-x, counsel uses the data from this for ordering
     smooth-scrolling        ; add a top and bottom margin when scrolling
     swiper                  ; buffer isearch using ivy
     undo-tree               ; better undo/redo, also has a visualizer
     unicode-fonts           ; support all the unicode characters
     use-package             ; pretty package initialization
     visual-regexp-steroids  ; better regular expressions
     wgrep                   ; editable grep buffer
     yasnippet               ; insert templates based on snippets
     which-key               ; popup after 1s, showing keybindings based on prefix key pressed

     ;; themes
     zenburn-theme           ; the great zenburn theme
     )
   )
  )
#+END_SRC

* Package initialization
#+BEGIN_SRC emacs-lisp
(message (format "= \e[1m\e[32mStarted Package Initialization\e[0m"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun try-require (feature)
  "Tries to require FEATURE, if an exception is thrown, log it."
  (condition-case ex
      (progn
        (message (format "@ \e[94m Loading \"%s\" \e[0m" (symbol-name feature)))
        (require feature))
    ('error (message (format "@ \e[1m\e[31m Error loading \"%s\": %s \e[0m" (symbol-name feature) ex)))))

(defvar package-init-files
  '(
    init-package-powerline
    ;; init-package-autocomplete
    init-package-multi-term
    init-package-ivy
    init-package-use-packages
    ))

;; Safely load all the init files
(message "## \e[36m Started loading package init files \e[0m")
(dolist (file package-init-files)
  (try-require file))
(message "## \e[36m Finished loading package init files \e[0m")
#+END_SRC

** Autocomplete
#+BEGIN_SRC emacs-lisp
(require 'auto-complete)
(require 'auto-complete-config)

;; (diminish 'abbrev-mode)

(defun ac-quick-help-at-point ()
  (interactive)
  (let* ((position (point))
         (string-under-cursor
          (buffer-substring-no-properties
           (progn (skip-syntax-backward "w_") (point))
           (progn (skip-syntax-forward "w_") (point)))))
    (goto-char position)
    (popup-tip (ac-symbol-documentation (intern string-under-cursor)))))

(defun my-ac-c++-mode-setup ()
  ;; (require 'ac-clang)
  ;; (require 'ac-c-headers)
  (require 'ac-rtags)

  (setq c++-include-files
        '("/usr/include"
          "/usr/include/c++/7.2.0"
          "/usr/include/c++/7.2.0/backward"
          "/usr/include/c++/7.2.0/x86_64-unknown-linux-gnu"
          "/usr/lib/gcc/x86_64-unknown-linux-gnu/7.2.0/include"
          "/usr/lib/gcc/x86_64-unknown-linux-gnu/7.2.0/include-fixed"
          "/usr/lib/clang/5.0.0/include"))

  (setq-default achead:include-directories c++-include-files)

  (add-to-list 'ac-sources 'ac-source-semantic)
  (add-to-list 'ac-sources 'ac-source-rtags)
  ;; (add-to-list 'ac-sources 'ac-source-c-headers)
  ;; (add-to-list 'ac-sources 'ac-source-c-header-symbols t)

  ;; (add-to-list 'ac-sources 'ac-source-clang)
  ;; (setq ac-clang-flags (mapcar (lambda (item)(concat "-I" item)) c++-include-files))
  ;; (ac-clang-activate-after-modify)
  )
(add-hook 'c++-mode-hook 'my-ac-c++-mode-setup)

(defun my-ac-elisp-mode-setup ()
  (add-to-list 'ac-sources 'ac-source-functions) ;; elisp functions
  (add-to-list 'ac-sources 'ac-source-features) ;; elisp features
  (add-to-list 'ac-sources 'ac-source-symbols) ;; elisp symbols
  (add-to-list 'ac-sources 'ac-source-variables)) ;; elisp variables
(add-hook 'emacs-lisp-mode-hook 'my-ac-elisp-mode-setup)

;; (defun my-ac-latex-mode-setup ()
;;   (require 'auto-complete-auctex)
;;   (require 'ac-auctex-setup))
;; (add-hook 'latex-mode-hook 'my-ac-latex-mode-setup)

;;(defun my-ac-octave-mode-setup ()
;;  (require 'ac-octave)
;;  (add-to-list 'ac-sources 'ac-complete-octave))
;; (add-hook 'octave-mode-hook 'my-ac-octave-mode-setup)
#+END_SRC

** Multi-term
** Ivy


Add stuff from =lisp/misc/= the the load path.
#+BEGIN_SRC
(add-to-list 'load-path (concat my-emacs-lisp-dir "misc/"))
#+END_SRC

* Use-packages
#+BEGIN_SRC emacs-lisp
;; give buffers unique names
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward))

(use-package tramp
  :config
  (setq tramp-persistency-file-name (concat my-emacs-data-dir "tramp")))

;; Save point position between sessions
(use-package saveplace
  :config
  (setq-default save-place t)
  (setq save-place-file (concat my-emacs-data-dir "saveplaces")))

;; Persist some vars across sessions
(use-package savehist
  :config
  (setq savehist-file (concat my-emacs-data-dir "savehist"))
  (setq savehist-autosave-interval 60) ;; save every minute
  (setq savehist-additional-variables '(search-ring
                                        regexp-search-ring))
  (savehist-mode 1))

;; Save a list of recently visited files.
(use-package recentf
  :config
  (setq recentf-save-file (recentf-expand-file-name (concat my-emacs-data-dir "recentf")))
  (setq recentf-exclude '(".emacs.d/elpa/" ".emacs.d/data/" "COMMIT_EDITMSG"))
  (setq recentf-max-saved-items 500) ;; just 20 is too few
  (setq recentf-auto-cleanup 300) ;; cleanup every 5 mins.
  ;; save recentf file every 30s, but don't bother us about it
  (setq recentf-auto-save-timer
        (run-with-idle-timer 30 t '(lambda ()
                                     (with-supressed-message (recentf-save-list)))))
  (recentf-mode 1))

#+END_SRC

* Package specific things
* Advices and Hooks
When popping the mark, continue popping until the cursor actually
moves. also, if the last command was a copy - skip past all the
expand-region cruft.
#+BEGIN_SRC emacs-lisp
(defadvice pop-to-mark-command (around ensure-new-position activate)
  (let ((p (point)))
    (when (eq last-command 'save-region-or-current-line)
      ad-do-it
      ad-do-it
      ad-do-it)
    (dotimes (i 10)
      (when (= p (point)) ad-do-it))))
#+END_SRC

Create nonexistent directories when saving a file
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (not (file-exists-p dir))
                  (make-directory dir t))))))
#+END_SRC

When using =magit-status=, just fill the entire screen, and jump back the the
previous window configuration when quitting magit.
#+BEGIN_SRC emacs-lisp
(defadvice magit-status (around magit-fullscreen activate)
  "Saves window configuration, then opens magit in fullscreen"
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))
#+END_SRC

If a region is active, use that as the initial input for searching in the
buffer.
#+BEGIN_SRC emacs-lisp
(defun my-counsel-grep-or-swiper (orig-fun &rest args)
  "Start searching with the region as initial input"
  (if (region-active-p)
      (let ((start (region-beginning))
            (end (region-end)))
        (deactivate-mark)
        (apply orig-fun (list (buffer-substring-no-properties start end))))
    (funcall orig-fun)))

(advice-add 'counsel-grep-or-swiper :around #'my-counsel-grep-or-swiper)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice undo-tree-undo (around keep-region activate)
  "Keep the region when undoing inside region"
  (if (use-region-p)
      (let ((m (set-marker (make-marker) (mark)))
            (p (set-marker (make-marker) (point))))
        ad-do-it
        (goto-char p)
        (set-mark m)
        (set-marker p nil)
        (set-marker m nil))
    ad-do-it))

(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(advice-add 'dired-readin :after #'mydired-sort)
#+END_SRC

* Keybindings

* tty

* Homemade modes

* Experimental

* Epilogue
#+BEGIN_SRC emacs-lisp
(message (format "= \e[1m\e[32mEmacs initialized in %s\e[0m" (emacs-init-time)))
#+END_SRC
